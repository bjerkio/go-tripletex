// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Company company
//
// swagger:model Company
type Company struct {

	// address
	// Required: true
	Address *Address `json:"address"`

	// changes
	// Read Only: true
	Changes []*Change `json:"changes"`

	// email
	// Max Length: 254
	// Format: email
	Email strfmt.Email `json:"email,omitempty"`

	// end date
	EndDate string `json:"endDate,omitempty"`

	// fax number
	// Max Length: 100
	FaxNumber string `json:"faxNumber,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// name
	// Required: true
	// Max Length: 255
	Name *string `json:"name"`

	// organization number
	// Max Length: 100
	OrganizationNumber string `json:"organizationNumber,omitempty"`

	// phone number
	// Max Length: 100
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// phone number mobile
	// Max Length: 100
	PhoneNumberMobile string `json:"phoneNumberMobile,omitempty"`

	// start date
	StartDate string `json:"startDate,omitempty"`

	// type
	// Required: true
	// Enum: [NONE ENK AS NUF ANS DA PRE KS ASA BBL BRL GFS SPA SF IKS KF_FKF FCD EOFG BA STI ORG ESEK SA SAM BO VPFO OS Other]
	Type *string `json:"type"`

	// url
	// Read Only: true
	URL string `json:"url,omitempty"`

	// version
	Version int32 `json:"version,omitempty"`
}

// Validate validates this company
func (m *Company) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFaxNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganizationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhoneNumberMobile(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Company) validateAddress(formats strfmt.Registry) error {

	if err := validate.Required("address", "body", m.Address); err != nil {
		return err
	}

	if m.Address != nil {
		if err := m.Address.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("address")
			}
			return err
		}
	}

	return nil
}

func (m *Company) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	for i := 0; i < len(m.Changes); i++ {
		if swag.IsZero(m.Changes[i]) { // not required
			continue
		}

		if m.Changes[i] != nil {
			if err := m.Changes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("changes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Company) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(m.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("email", "body", string(m.Email), 254); err != nil {
		return err
	}

	if err := validate.FormatOf("email", "body", "email", m.Email.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Company) validateFaxNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.FaxNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("faxNumber", "body", string(m.FaxNumber), 100); err != nil {
		return err
	}

	return nil
}

func (m *Company) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 255); err != nil {
		return err
	}

	return nil
}

func (m *Company) validateOrganizationNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.OrganizationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("organizationNumber", "body", string(m.OrganizationNumber), 100); err != nil {
		return err
	}

	return nil
}

func (m *Company) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("phoneNumber", "body", string(m.PhoneNumber), 100); err != nil {
		return err
	}

	return nil
}

func (m *Company) validatePhoneNumberMobile(formats strfmt.Registry) error {

	if swag.IsZero(m.PhoneNumberMobile) { // not required
		return nil
	}

	if err := validate.MaxLength("phoneNumberMobile", "body", string(m.PhoneNumberMobile), 100); err != nil {
		return err
	}

	return nil
}

var companyTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","ENK","AS","NUF","ANS","DA","PRE","KS","ASA","BBL","BRL","GFS","SPA","SF","IKS","KF_FKF","FCD","EOFG","BA","STI","ORG","ESEK","SA","SAM","BO","VPFO","OS","Other"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		companyTypeTypePropEnum = append(companyTypeTypePropEnum, v)
	}
}

const (

	// CompanyTypeNONE captures enum value "NONE"
	CompanyTypeNONE string = "NONE"

	// CompanyTypeENK captures enum value "ENK"
	CompanyTypeENK string = "ENK"

	// CompanyTypeAS captures enum value "AS"
	CompanyTypeAS string = "AS"

	// CompanyTypeNUF captures enum value "NUF"
	CompanyTypeNUF string = "NUF"

	// CompanyTypeANS captures enum value "ANS"
	CompanyTypeANS string = "ANS"

	// CompanyTypeDA captures enum value "DA"
	CompanyTypeDA string = "DA"

	// CompanyTypePRE captures enum value "PRE"
	CompanyTypePRE string = "PRE"

	// CompanyTypeKS captures enum value "KS"
	CompanyTypeKS string = "KS"

	// CompanyTypeASA captures enum value "ASA"
	CompanyTypeASA string = "ASA"

	// CompanyTypeBBL captures enum value "BBL"
	CompanyTypeBBL string = "BBL"

	// CompanyTypeBRL captures enum value "BRL"
	CompanyTypeBRL string = "BRL"

	// CompanyTypeGFS captures enum value "GFS"
	CompanyTypeGFS string = "GFS"

	// CompanyTypeSPA captures enum value "SPA"
	CompanyTypeSPA string = "SPA"

	// CompanyTypeSF captures enum value "SF"
	CompanyTypeSF string = "SF"

	// CompanyTypeIKS captures enum value "IKS"
	CompanyTypeIKS string = "IKS"

	// CompanyTypeKFFKF captures enum value "KF_FKF"
	CompanyTypeKFFKF string = "KF_FKF"

	// CompanyTypeFCD captures enum value "FCD"
	CompanyTypeFCD string = "FCD"

	// CompanyTypeEOFG captures enum value "EOFG"
	CompanyTypeEOFG string = "EOFG"

	// CompanyTypeBA captures enum value "BA"
	CompanyTypeBA string = "BA"

	// CompanyTypeSTI captures enum value "STI"
	CompanyTypeSTI string = "STI"

	// CompanyTypeORG captures enum value "ORG"
	CompanyTypeORG string = "ORG"

	// CompanyTypeESEK captures enum value "ESEK"
	CompanyTypeESEK string = "ESEK"

	// CompanyTypeSA captures enum value "SA"
	CompanyTypeSA string = "SA"

	// CompanyTypeSAM captures enum value "SAM"
	CompanyTypeSAM string = "SAM"

	// CompanyTypeBO captures enum value "BO"
	CompanyTypeBO string = "BO"

	// CompanyTypeVPFO captures enum value "VPFO"
	CompanyTypeVPFO string = "VPFO"

	// CompanyTypeOS captures enum value "OS"
	CompanyTypeOS string = "OS"

	// CompanyTypeOther captures enum value "Other"
	CompanyTypeOther string = "Other"
)

// prop value enum
func (m *Company) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, companyTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Company) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Company) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Company) UnmarshalBinary(b []byte) error {
	var res Company
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
