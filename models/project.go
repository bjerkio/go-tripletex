// Copyright 2020 Bjerk AS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Project project
//
// swagger:model Project
type Project struct {

	// changes
	// Read Only: true
	Changes []*Change `json:"changes"`

	// contact
	// Read Only: true
	Contact *Contact `json:"contact,omitempty"`

	// contribution margin percent
	// Read Only: true
	ContributionMarginPercent float64 `json:"contributionMarginPercent,omitempty"`

	// currency
	Currency *Currency `json:"currency,omitempty"`

	// The project's customer
	Customer *Customer `json:"customer,omitempty"`

	// delivery address
	// Read Only: true
	DeliveryAddress *DeliveryAddress `json:"deliveryAddress,omitempty"`

	// department
	Department *Department `json:"department,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// Project discount percentage.
	// Read Only: true
	DiscountPercentage float64 `json:"discountPercentage,omitempty"`

	// display name
	// Read Only: true
	DisplayName string `json:"displayName,omitempty"`

	// Defines project name presentation in overviews.
	// Enum: [NAME_STANDARD NAME_INCL_CUSTOMER_NAME NAME_INCL_PARENT_NAME NAME_INCL_PARENT_NUMBER NAME_INCL_PARENT_NAME_AND_NUMBER]
	DisplayNameFormat string `json:"displayNameFormat,omitempty"`

	// end date
	EndDate string `json:"endDate,omitempty"`

	// external accounts number
	// Max Length: 100
	ExternalAccountsNumber string `json:"externalAccountsNumber,omitempty"`

	// Project markup percentage.
	// Read Only: true
	ExtraPercentOrderLines float64 `json:"extraPercentOrderLines,omitempty"`

	// Fixed price amount, in the project's currency.
	Fixedprice float64 `json:"fixedprice,omitempty"`

	// Set to true if only project participants can register information on the project
	ForParticipantsOnly *bool `json:"forParticipantsOnly,omitempty"`

	// Set to true if a general project activity must be linked to project to allow time tracking.
	GeneralProjectActivitiesPerProjectOnly *bool `json:"generalProjectActivitiesPerProjectOnly,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// Invoicing plans tied to the project
	// Read Only: true
	InvoicingPlan []*Invoice `json:"invoicingPlan"`

	// is closed
	IsClosed *bool `json:"isClosed,omitempty"`

	// Project is fixed price if set to true, hourly rate if set to false.
	IsFixedPrice *bool `json:"isFixedPrice,omitempty"`

	// is internal
	// Required: true
	IsInternal bool `json:"isInternal"`

	// is offer
	// Read Only: true
	IsOffer *bool `json:"isOffer,omitempty"`

	// Set to true if an hourly rate project has a price ceiling.
	IsPriceCeiling *bool `json:"isPriceCeiling,omitempty"`

	// is ready for invoicing
	IsReadyForInvoicing *bool `json:"isReadyForInvoicing,omitempty"`

	// main project
	MainProject *Project `json:"mainProject,omitempty"`

	// Set mark-up (%) for fees earned.
	MarkUpFeesEarned float64 `json:"markUpFeesEarned,omitempty"`

	// Set mark-up (%) for order lines.
	MarkUpOrderLines float64 `json:"markUpOrderLines,omitempty"`

	// name
	// Required: true
	// Max Length: 255
	Name *string `json:"name"`

	// number
	// Max Length: 100
	Number string `json:"number,omitempty"`

	// number of project participants
	// Read Only: true
	NumberOfProjectParticipants int32 `json:"numberOfProjectParticipants,omitempty"`

	// number of sub projects
	// Read Only: true
	NumberOfSubProjects int32 `json:"numberOfSubProjects,omitempty"`

	// Order lines tied to the order
	// Read Only: true
	OrderLines []*ProjectOrderLine `json:"orderLines"`

	// Link to individual project participants.
	Participants []*ProjectParticipant `json:"participants"`

	// preliminary invoice
	// Read Only: true
	PreliminaryInvoice *Invoice `json:"preliminaryInvoice,omitempty"`

	// Price ceiling amount, in the project's currency.
	PriceCeilingAmount float64 `json:"priceCeilingAmount,omitempty"`

	// Project Activities
	ProjectActivities []*ProjectActivity `json:"projectActivities"`

	// project category
	ProjectCategory *ProjectCategory `json:"projectCategory,omitempty"`

	// Project Rate Types tied to the project.
	ProjectHourlyRates []*ProjectHourlyRate `json:"projectHourlyRates"`

	// project manager
	// Required: true
	ProjectManager *Employee `json:"projectManager"`

	// start date
	// Required: true
	StartDate *string `json:"startDate"`

	// url
	// Read Only: true
	URL string `json:"url,omitempty"`

	// The default vat type for this project.
	VatType *VatType `json:"vatType,omitempty"`

	// version
	Version int32 `json:"version,omitempty"`
}

// Validate validates this project
func (m *Project) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateChanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayNameFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExternalAccountsNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoicingPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsInternal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMainProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderLines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateParticipants(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreliminaryInvoice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectActivities(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectHourlyRates(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProjectManager(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVatType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Project) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	for i := 0; i < len(m.Changes); i++ {
		if swag.IsZero(m.Changes[i]) { // not required
			continue
		}

		if m.Changes[i] != nil {
			if err := m.Changes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("changes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Project) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(m.Contact) { // not required
		return nil
	}

	if m.Contact != nil {
		if err := m.Contact.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contact")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(m.Customer) { // not required
		return nil
	}

	if m.Customer != nil {
		if err := m.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customer")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateDeliveryAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.DeliveryAddress) { // not required
		return nil
	}

	if m.DeliveryAddress != nil {
		if err := m.DeliveryAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deliveryAddress")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateDepartment(formats strfmt.Registry) error {

	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

var projectTypeDisplayNameFormatPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NAME_STANDARD","NAME_INCL_CUSTOMER_NAME","NAME_INCL_PARENT_NAME","NAME_INCL_PARENT_NUMBER","NAME_INCL_PARENT_NAME_AND_NUMBER"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		projectTypeDisplayNameFormatPropEnum = append(projectTypeDisplayNameFormatPropEnum, v)
	}
}

const (

	// ProjectDisplayNameFormatNAMESTANDARD captures enum value "NAME_STANDARD"
	ProjectDisplayNameFormatNAMESTANDARD string = "NAME_STANDARD"

	// ProjectDisplayNameFormatNAMEINCLCUSTOMERNAME captures enum value "NAME_INCL_CUSTOMER_NAME"
	ProjectDisplayNameFormatNAMEINCLCUSTOMERNAME string = "NAME_INCL_CUSTOMER_NAME"

	// ProjectDisplayNameFormatNAMEINCLPARENTNAME captures enum value "NAME_INCL_PARENT_NAME"
	ProjectDisplayNameFormatNAMEINCLPARENTNAME string = "NAME_INCL_PARENT_NAME"

	// ProjectDisplayNameFormatNAMEINCLPARENTNUMBER captures enum value "NAME_INCL_PARENT_NUMBER"
	ProjectDisplayNameFormatNAMEINCLPARENTNUMBER string = "NAME_INCL_PARENT_NUMBER"

	// ProjectDisplayNameFormatNAMEINCLPARENTNAMEANDNUMBER captures enum value "NAME_INCL_PARENT_NAME_AND_NUMBER"
	ProjectDisplayNameFormatNAMEINCLPARENTNAMEANDNUMBER string = "NAME_INCL_PARENT_NAME_AND_NUMBER"
)

// prop value enum
func (m *Project) validateDisplayNameFormatEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, projectTypeDisplayNameFormatPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Project) validateDisplayNameFormat(formats strfmt.Registry) error {

	if swag.IsZero(m.DisplayNameFormat) { // not required
		return nil
	}

	// value enum
	if err := m.validateDisplayNameFormatEnum("displayNameFormat", "body", m.DisplayNameFormat); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateExternalAccountsNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.ExternalAccountsNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("externalAccountsNumber", "body", string(m.ExternalAccountsNumber), 100); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateInvoicingPlan(formats strfmt.Registry) error {

	if swag.IsZero(m.InvoicingPlan) { // not required
		return nil
	}

	for i := 0; i < len(m.InvoicingPlan); i++ {
		if swag.IsZero(m.InvoicingPlan[i]) { // not required
			continue
		}

		if m.InvoicingPlan[i] != nil {
			if err := m.InvoicingPlan[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("invoicingPlan" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Project) validateIsInternal(formats strfmt.Registry) error {

	if err := validate.Required("isInternal", "body", bool(m.IsInternal)); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateMainProject(formats strfmt.Registry) error {

	if swag.IsZero(m.MainProject) { // not required
		return nil
	}

	if m.MainProject != nil {
		if err := m.MainProject.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("mainProject")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 255); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("number", "body", string(m.Number), 100); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateOrderLines(formats strfmt.Registry) error {

	if swag.IsZero(m.OrderLines) { // not required
		return nil
	}

	for i := 0; i < len(m.OrderLines); i++ {
		if swag.IsZero(m.OrderLines[i]) { // not required
			continue
		}

		if m.OrderLines[i] != nil {
			if err := m.OrderLines[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orderLines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Project) validateParticipants(formats strfmt.Registry) error {

	if swag.IsZero(m.Participants) { // not required
		return nil
	}

	for i := 0; i < len(m.Participants); i++ {
		if swag.IsZero(m.Participants[i]) { // not required
			continue
		}

		if m.Participants[i] != nil {
			if err := m.Participants[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("participants" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Project) validatePreliminaryInvoice(formats strfmt.Registry) error {

	if swag.IsZero(m.PreliminaryInvoice) { // not required
		return nil
	}

	if m.PreliminaryInvoice != nil {
		if err := m.PreliminaryInvoice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("preliminaryInvoice")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateProjectActivities(formats strfmt.Registry) error {

	if swag.IsZero(m.ProjectActivities) { // not required
		return nil
	}

	for i := 0; i < len(m.ProjectActivities); i++ {
		if swag.IsZero(m.ProjectActivities[i]) { // not required
			continue
		}

		if m.ProjectActivities[i] != nil {
			if err := m.ProjectActivities[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("projectActivities" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Project) validateProjectCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ProjectCategory) { // not required
		return nil
	}

	if m.ProjectCategory != nil {
		if err := m.ProjectCategory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("projectCategory")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateProjectHourlyRates(formats strfmt.Registry) error {

	if swag.IsZero(m.ProjectHourlyRates) { // not required
		return nil
	}

	for i := 0; i < len(m.ProjectHourlyRates); i++ {
		if swag.IsZero(m.ProjectHourlyRates[i]) { // not required
			continue
		}

		if m.ProjectHourlyRates[i] != nil {
			if err := m.ProjectHourlyRates[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("projectHourlyRates" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Project) validateProjectManager(formats strfmt.Registry) error {

	if err := validate.Required("projectManager", "body", m.ProjectManager); err != nil {
		return err
	}

	if m.ProjectManager != nil {
		if err := m.ProjectManager.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("projectManager")
			}
			return err
		}
	}

	return nil
}

func (m *Project) validateStartDate(formats strfmt.Registry) error {

	if err := validate.Required("startDate", "body", m.StartDate); err != nil {
		return err
	}

	return nil
}

func (m *Project) validateVatType(formats strfmt.Registry) error {

	if swag.IsZero(m.VatType) { // not required
		return nil
	}

	if m.VatType != nil {
		if err := m.VatType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vatType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Project) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Project) UnmarshalBinary(b []byte) error {
	var res Project
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
