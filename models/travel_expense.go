// Copyright 2020 Bjerk AS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TravelExpense travel expense
//
// swagger:model TravelExpense
type TravelExpense struct {

	// Link to individual accommodation allowances.
	// Read Only: true
	AccommodationAllowances []*AccommodationAllowance `json:"accommodationAllowances"`

	// accounting period closed
	// Read Only: true
	AccountingPeriodClosed *bool `json:"accountingPeriodClosed,omitempty"`

	// accounting period v a t closed
	// Read Only: true
	AccountingPeriodVATClosed *bool `json:"accountingPeriodVATClosed,omitempty"`

	// actions
	// Read Only: true
	Actions []*Link `json:"actions"`

	// amount
	// Read Only: true
	Amount float64 `json:"amount,omitempty"`

	// approved by
	// Read Only: true
	ApprovedBy *Employee `json:"approvedBy,omitempty"`

	// approved date
	// Read Only: true
	ApprovedDate string `json:"approvedDate,omitempty"`

	// attachment
	// Read Only: true
	Attachment *Document `json:"attachment,omitempty"`

	// attachment count
	// Read Only: true
	// Maximum: 2.147483647e+09
	// Minimum: 0
	AttachmentCount int32 `json:"attachmentCount,omitempty"`

	// changes
	// Read Only: true
	Changes []*Change `json:"changes"`

	// chargeable amount
	// Read Only: true
	ChargeableAmount float64 `json:"chargeableAmount,omitempty"`

	// completed by
	// Read Only: true
	CompletedBy *Employee `json:"completedBy,omitempty"`

	// completed date
	// Read Only: true
	CompletedDate string `json:"completedDate,omitempty"`

	// Link to individual costs.
	Costs []*Cost `json:"costs"`

	// date
	// Read Only: true
	Date string `json:"date,omitempty"`

	// department
	Department *Department `json:"department,omitempty"`

	// employee
	// Required: true
	Employee *Employee `json:"employee"`

	// fixed invoiced amount
	FixedInvoicedAmount float64 `json:"fixedInvoicedAmount,omitempty"`

	// high rate v a t
	// Read Only: true
	HighRateVAT float64 `json:"highRateVAT,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// invoice
	// Read Only: true
	Invoice *Invoice `json:"invoice,omitempty"`

	// is approved
	// Read Only: true
	IsApproved *bool `json:"isApproved,omitempty"`

	// is chargeable
	IsChargeable *bool `json:"isChargeable,omitempty"`

	// is completed
	// Read Only: true
	IsCompleted *bool `json:"isCompleted,omitempty"`

	// is fixed invoiced amount
	IsFixedInvoicedAmount *bool `json:"isFixedInvoicedAmount,omitempty"`

	// is include attached receipts when reinvoicing
	IsIncludeAttachedReceiptsWhenReinvoicing *bool `json:"isIncludeAttachedReceiptsWhenReinvoicing,omitempty"`

	// is salary admin
	// Read Only: true
	IsSalaryAdmin *bool `json:"isSalaryAdmin,omitempty"`

	// low rate v a t
	// Read Only: true
	LowRateVAT float64 `json:"lowRateVAT,omitempty"`

	// medium rate v a t
	// Read Only: true
	MediumRateVAT float64 `json:"mediumRateVAT,omitempty"`

	// Link to individual mileage allowances.
	// Read Only: true
	MileageAllowances []*MileageAllowance `json:"mileageAllowances"`

	// number
	// Read Only: true
	Number int32 `json:"number,omitempty"`

	// payment amount
	// Read Only: true
	PaymentAmount float64 `json:"paymentAmount,omitempty"`

	// payment amount currency
	// Read Only: true
	PaymentAmountCurrency float64 `json:"paymentAmountCurrency,omitempty"`

	// payment currency
	PaymentCurrency *Currency `json:"paymentCurrency,omitempty"`

	// payslip
	// Read Only: true
	Payslip *Payslip `json:"payslip,omitempty"`

	// Link to individual per diem compensations.
	PerDiemCompensations []*PerDiemCompensation `json:"perDiemCompensations"`

	// project
	Project *Project `json:"project,omitempty"`

	// show payslip
	// Read Only: true
	ShowPayslip *bool `json:"showPayslip,omitempty"`

	// state
	// Read Only: true
	// Enum: [ALL OPEN APPROVED SALARY_PAID DELIVERED]
	State string `json:"state,omitempty"`

	// title
	// Max Length: 255
	Title string `json:"title,omitempty"`

	// travel advance
	TravelAdvance float64 `json:"travelAdvance,omitempty"`

	// travel details
	TravelDetails *TravelDetails `json:"travelDetails,omitempty"`

	// url
	// Read Only: true
	URL string `json:"url,omitempty"`

	// vat type
	VatType *VatType `json:"vatType,omitempty"`

	// version
	Version int32 `json:"version,omitempty"`

	// voucher
	// Read Only: true
	Voucher *Voucher `json:"voucher,omitempty"`
}

// Validate validates this travel expense
func (m *TravelExpense) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccommodationAllowances(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateApprovedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttachment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAttachmentCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompletedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCosts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMileageAllowances(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePaymentCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePayslip(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePerDiemCompensations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTravelDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVatType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoucher(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TravelExpense) validateAccommodationAllowances(formats strfmt.Registry) error {

	if swag.IsZero(m.AccommodationAllowances) { // not required
		return nil
	}

	for i := 0; i < len(m.AccommodationAllowances); i++ {
		if swag.IsZero(m.AccommodationAllowances[i]) { // not required
			continue
		}

		if m.AccommodationAllowances[i] != nil {
			if err := m.AccommodationAllowances[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("accommodationAllowances" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TravelExpense) validateActions(formats strfmt.Registry) error {

	if swag.IsZero(m.Actions) { // not required
		return nil
	}

	for i := 0; i < len(m.Actions); i++ {
		if swag.IsZero(m.Actions[i]) { // not required
			continue
		}

		if m.Actions[i] != nil {
			if err := m.Actions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("actions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TravelExpense) validateApprovedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.ApprovedBy) { // not required
		return nil
	}

	if m.ApprovedBy != nil {
		if err := m.ApprovedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("approvedBy")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateAttachment(formats strfmt.Registry) error {

	if swag.IsZero(m.Attachment) { // not required
		return nil
	}

	if m.Attachment != nil {
		if err := m.Attachment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attachment")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateAttachmentCount(formats strfmt.Registry) error {

	if swag.IsZero(m.AttachmentCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("attachmentCount", "body", int64(m.AttachmentCount), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("attachmentCount", "body", int64(m.AttachmentCount), 2.147483647e+09, false); err != nil {
		return err
	}

	return nil
}

func (m *TravelExpense) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	for i := 0; i < len(m.Changes); i++ {
		if swag.IsZero(m.Changes[i]) { // not required
			continue
		}

		if m.Changes[i] != nil {
			if err := m.Changes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("changes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TravelExpense) validateCompletedBy(formats strfmt.Registry) error {

	if swag.IsZero(m.CompletedBy) { // not required
		return nil
	}

	if m.CompletedBy != nil {
		if err := m.CompletedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("completedBy")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateCosts(formats strfmt.Registry) error {

	if swag.IsZero(m.Costs) { // not required
		return nil
	}

	for i := 0; i < len(m.Costs); i++ {
		if swag.IsZero(m.Costs[i]) { // not required
			continue
		}

		if m.Costs[i] != nil {
			if err := m.Costs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("costs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TravelExpense) validateDepartment(formats strfmt.Registry) error {

	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateEmployee(formats strfmt.Registry) error {

	if err := validate.Required("employee", "body", m.Employee); err != nil {
		return err
	}

	if m.Employee != nil {
		if err := m.Employee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("employee")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateInvoice(formats strfmt.Registry) error {

	if swag.IsZero(m.Invoice) { // not required
		return nil
	}

	if m.Invoice != nil {
		if err := m.Invoice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("invoice")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateMileageAllowances(formats strfmt.Registry) error {

	if swag.IsZero(m.MileageAllowances) { // not required
		return nil
	}

	for i := 0; i < len(m.MileageAllowances); i++ {
		if swag.IsZero(m.MileageAllowances[i]) { // not required
			continue
		}

		if m.MileageAllowances[i] != nil {
			if err := m.MileageAllowances[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("mileageAllowances" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TravelExpense) validatePaymentCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.PaymentCurrency) { // not required
		return nil
	}

	if m.PaymentCurrency != nil {
		if err := m.PaymentCurrency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("paymentCurrency")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validatePayslip(formats strfmt.Registry) error {

	if swag.IsZero(m.Payslip) { // not required
		return nil
	}

	if m.Payslip != nil {
		if err := m.Payslip.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payslip")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validatePerDiemCompensations(formats strfmt.Registry) error {

	if swag.IsZero(m.PerDiemCompensations) { // not required
		return nil
	}

	for i := 0; i < len(m.PerDiemCompensations); i++ {
		if swag.IsZero(m.PerDiemCompensations[i]) { // not required
			continue
		}

		if m.PerDiemCompensations[i] != nil {
			if err := m.PerDiemCompensations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("perDiemCompensations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TravelExpense) validateProject(formats strfmt.Registry) error {

	if swag.IsZero(m.Project) { // not required
		return nil
	}

	if m.Project != nil {
		if err := m.Project.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("project")
			}
			return err
		}
	}

	return nil
}

var travelExpenseTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ALL","OPEN","APPROVED","SALARY_PAID","DELIVERED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		travelExpenseTypeStatePropEnum = append(travelExpenseTypeStatePropEnum, v)
	}
}

const (

	// TravelExpenseStateALL captures enum value "ALL"
	TravelExpenseStateALL string = "ALL"

	// TravelExpenseStateOPEN captures enum value "OPEN"
	TravelExpenseStateOPEN string = "OPEN"

	// TravelExpenseStateAPPROVED captures enum value "APPROVED"
	TravelExpenseStateAPPROVED string = "APPROVED"

	// TravelExpenseStateSALARYPAID captures enum value "SALARY_PAID"
	TravelExpenseStateSALARYPAID string = "SALARY_PAID"

	// TravelExpenseStateDELIVERED captures enum value "DELIVERED"
	TravelExpenseStateDELIVERED string = "DELIVERED"
)

// prop value enum
func (m *TravelExpense) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, travelExpenseTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TravelExpense) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *TravelExpense) validateTitle(formats strfmt.Registry) error {

	if swag.IsZero(m.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("title", "body", string(m.Title), 255); err != nil {
		return err
	}

	return nil
}

func (m *TravelExpense) validateTravelDetails(formats strfmt.Registry) error {

	if swag.IsZero(m.TravelDetails) { // not required
		return nil
	}

	if m.TravelDetails != nil {
		if err := m.TravelDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("travelDetails")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateVatType(formats strfmt.Registry) error {

	if swag.IsZero(m.VatType) { // not required
		return nil
	}

	if m.VatType != nil {
		if err := m.VatType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vatType")
			}
			return err
		}
	}

	return nil
}

func (m *TravelExpense) validateVoucher(formats strfmt.Registry) error {

	if swag.IsZero(m.Voucher) { // not required
		return nil
	}

	if m.Voucher != nil {
		if err := m.Voucher.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("voucher")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TravelExpense) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TravelExpense) UnmarshalBinary(b []byte) error {
	var res TravelExpense
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
