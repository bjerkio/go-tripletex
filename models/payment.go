// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Payment payment
//
// swagger:model Payment
type Payment struct {

	// The payment account.
	// Read Only: true
	Account *Account `json:"account,omitempty"`

	// In the specified currency.
	// Read Only: true
	AmountCurrency float64 `json:"amountCurrency,omitempty"`

	// booking date
	// Read Only: true
	BookingDate string `json:"bookingDate,omitempty"`

	// changes
	// Read Only: true
	Changes []*Change `json:"changes"`

	// creditor bank address
	// Read Only: true
	// Max Length: 255
	CreditorBankAddress string `json:"creditorBankAddress,omitempty"`

	// creditor bank name
	// Read Only: true
	// Max Length: 255
	CreditorBankName string `json:"creditorBankName,omitempty"`

	// creditor bank postal city
	// Read Only: true
	// Max Length: 255
	CreditorBankPostalCity string `json:"creditorBankPostalCity,omitempty"`

	// creditor bank postal code
	// Read Only: true
	// Max Length: 255
	CreditorBankPostalCode string `json:"creditorBankPostalCode,omitempty"`

	// currency
	// Read Only: true
	Currency *Currency `json:"currency,omitempty"`

	// description
	// Read Only: true
	// Max Length: 255
	Description string `json:"description,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// is final status
	// Read Only: true
	IsFinalStatus *bool `json:"isFinalStatus,omitempty"`

	// is foreign payment
	// Read Only: true
	IsForeignPayment *bool `json:"isForeignPayment,omitempty"`

	// is salary
	// Read Only: true
	IsSalary *bool `json:"isSalary,omitempty"`

	// KID - Kundeidentifikasjonsnummer.
	// Read Only: true
	// Max Length: 25
	Kid string `json:"kid,omitempty"`

	// payment date
	// Read Only: true
	PaymentDate string `json:"paymentDate,omitempty"`

	// The payment posting.
	// Read Only: true
	Postings *Posting `json:"postings,omitempty"`

	// receiver reference
	// Read Only: true
	// Max Length: 250
	ReceiverReference string `json:"receiverReference,omitempty"`

	// Vouchere that was paid.
	// Read Only: true
	SourceVoucher *Voucher `json:"sourceVoucher,omitempty"`

	// The payment status.NOT_APPROVED: Payment not approved yet.<br>APPROVED: Payment approved, but not yet sent to bank.<br>SENT_TO_AUTOPAY: Payment sent to bank.<br>RECEIVED_BY_BANK: Payment received by the bank.<br>ACCEPTED_BY_BANK: Payment that was accepted by the bank.<br>FAILED: Payment that failed.<br>CANCELLED: Cancelled payment.<br>SUCCESS: Payment that ended successfully.<br>
	// Read Only: true
	// Enum: [NOT_APPROVED APPROVED SENT_TO_AUTOPAY RECEIVED_BY_BANK ACCEPTED_BY_BANK FAILED CANCELLED SUCCESS]
	Status string `json:"status,omitempty"`

	// url
	// Read Only: true
	URL string `json:"url,omitempty"`

	// value date
	// Read Only: true
	ValueDate string `json:"valueDate,omitempty"`

	// version
	Version int32 `json:"version,omitempty"`
}

// Validate validates this payment
func (m *Payment) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditorBankAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditorBankName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditorBankPostalCity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditorBankPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePostings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiverReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceVoucher(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Payment) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	for i := 0; i < len(m.Changes); i++ {
		if swag.IsZero(m.Changes[i]) { // not required
			continue
		}

		if m.Changes[i] != nil {
			if err := m.Changes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("changes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Payment) validateCreditorBankAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditorBankAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("creditorBankAddress", "body", string(m.CreditorBankAddress), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCreditorBankName(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditorBankName) { // not required
		return nil
	}

	if err := validate.MaxLength("creditorBankName", "body", string(m.CreditorBankName), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCreditorBankPostalCity(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditorBankPostalCity) { // not required
		return nil
	}

	if err := validate.MaxLength("creditorBankPostalCity", "body", string(m.CreditorBankPostalCity), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCreditorBankPostalCode(formats strfmt.Registry) error {

	if swag.IsZero(m.CreditorBankPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("creditorBankPostalCode", "body", string(m.CreditorBankPostalCode), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", string(m.Description), 255); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateKid(formats strfmt.Registry) error {

	if swag.IsZero(m.Kid) { // not required
		return nil
	}

	if err := validate.MaxLength("kid", "body", string(m.Kid), 25); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validatePostings(formats strfmt.Registry) error {

	if swag.IsZero(m.Postings) { // not required
		return nil
	}

	if m.Postings != nil {
		if err := m.Postings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("postings")
			}
			return err
		}
	}

	return nil
}

func (m *Payment) validateReceiverReference(formats strfmt.Registry) error {

	if swag.IsZero(m.ReceiverReference) { // not required
		return nil
	}

	if err := validate.MaxLength("receiverReference", "body", string(m.ReceiverReference), 250); err != nil {
		return err
	}

	return nil
}

func (m *Payment) validateSourceVoucher(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceVoucher) { // not required
		return nil
	}

	if m.SourceVoucher != nil {
		if err := m.SourceVoucher.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sourceVoucher")
			}
			return err
		}
	}

	return nil
}

var paymentTypeStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NOT_APPROVED","APPROVED","SENT_TO_AUTOPAY","RECEIVED_BY_BANK","ACCEPTED_BY_BANK","FAILED","CANCELLED","SUCCESS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		paymentTypeStatusPropEnum = append(paymentTypeStatusPropEnum, v)
	}
}

const (

	// PaymentStatusNOTAPPROVED captures enum value "NOT_APPROVED"
	PaymentStatusNOTAPPROVED string = "NOT_APPROVED"

	// PaymentStatusAPPROVED captures enum value "APPROVED"
	PaymentStatusAPPROVED string = "APPROVED"

	// PaymentStatusSENTTOAUTOPAY captures enum value "SENT_TO_AUTOPAY"
	PaymentStatusSENTTOAUTOPAY string = "SENT_TO_AUTOPAY"

	// PaymentStatusRECEIVEDBYBANK captures enum value "RECEIVED_BY_BANK"
	PaymentStatusRECEIVEDBYBANK string = "RECEIVED_BY_BANK"

	// PaymentStatusACCEPTEDBYBANK captures enum value "ACCEPTED_BY_BANK"
	PaymentStatusACCEPTEDBYBANK string = "ACCEPTED_BY_BANK"

	// PaymentStatusFAILED captures enum value "FAILED"
	PaymentStatusFAILED string = "FAILED"

	// PaymentStatusCANCELLED captures enum value "CANCELLED"
	PaymentStatusCANCELLED string = "CANCELLED"

	// PaymentStatusSUCCESS captures enum value "SUCCESS"
	PaymentStatusSUCCESS string = "SUCCESS"
)

// prop value enum
func (m *Payment) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, paymentTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Payment) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Payment) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Payment) UnmarshalBinary(b []byte) error {
	var res Payment
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
