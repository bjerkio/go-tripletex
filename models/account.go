// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Account account
//
// swagger:model Account
type Account struct {

	// bank account country
	BankAccountCountry *Country `json:"bankAccountCountry,omitempty"`

	// bank account i b a n
	// Max Length: 100
	BankAccountIBAN string `json:"bankAccountIBAN,omitempty"`

	// bank account number
	// Max Length: 100
	BankAccountNumber string `json:"bankAccountNumber,omitempty"`

	// bank account s w i f t
	// Max Length: 100
	BankAccountSWIFT string `json:"bankAccountSWIFT,omitempty"`

	// bank name
	// Max Length: 255
	BankName string `json:"bankName,omitempty"`

	// changes
	// Read Only: true
	Changes []*Change `json:"changes"`

	// If given, all entries on this account must have this currency.
	Currency *Currency `json:"currency,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// True if this account is applicable for supplier invoice registration.
	IsApplicableForSupplierInvoice *bool `json:"isApplicableForSupplierInvoice,omitempty"`

	// is bank account
	IsBankAccount *bool `json:"isBankAccount,omitempty"`

	// True if it should be possible to close entries on this account and it is possible to filter on open entries.
	IsCloseable *bool `json:"isCloseable,omitempty"`

	// Inactive accounts will not show up in UI lists.
	IsInactive *bool `json:"isInactive,omitempty"`

	// is invoice account
	IsInvoiceAccount *bool `json:"isInvoiceAccount,omitempty"`

	// name
	// Required: true
	// Max Length: 255
	Name *string `json:"name"`

	// number
	// Required: true
	// Minimum: 0
	Number *int32 `json:"number"`

	// True if this account must be reconciled before the accounting period closure.
	RequireReconciliation *bool `json:"requireReconciliation,omitempty"`

	// type
	// Read Only: true
	// Enum: [ASSETS EQUITY LIABILITIES OPERATING_REVENUES OPERATING_EXPENSES INVESTMENT_INCOME COST_OF_CAPITAL TAX_ON_ORDINARY_ACTIVITIES EXTRAORDINARY_INCOME EXTRAORDINARY_COST TAX_ON_EXTRAORDINARY_ACTIVITIES ANNUAL_RESULT TRANSFERS_AND_ALLOCATIONS]
	Type string `json:"type,omitempty"`

	// url
	// Read Only: true
	URL string `json:"url,omitempty"`

	// True if all entries on this account must have the vat type given by vatType.
	VatLocked *bool `json:"vatLocked,omitempty"`

	// The default vat type for this account.
	VatType *VatType `json:"vatType,omitempty"`

	// version
	Version int32 `json:"version,omitempty"`
}

// Validate validates this account
func (m *Account) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBankAccountCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccountIBAN(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankAccountSWIFT(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBankName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVatType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Account) validateBankAccountCountry(formats strfmt.Registry) error {

	if swag.IsZero(m.BankAccountCountry) { // not required
		return nil
	}

	if m.BankAccountCountry != nil {
		if err := m.BankAccountCountry.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccountCountry")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateBankAccountIBAN(formats strfmt.Registry) error {

	if swag.IsZero(m.BankAccountIBAN) { // not required
		return nil
	}

	if err := validate.MaxLength("bankAccountIBAN", "body", string(m.BankAccountIBAN), 100); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateBankAccountNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.BankAccountNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("bankAccountNumber", "body", string(m.BankAccountNumber), 100); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateBankAccountSWIFT(formats strfmt.Registry) error {

	if swag.IsZero(m.BankAccountSWIFT) { // not required
		return nil
	}

	if err := validate.MaxLength("bankAccountSWIFT", "body", string(m.BankAccountSWIFT), 100); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateBankName(formats strfmt.Registry) error {

	if swag.IsZero(m.BankName) { // not required
		return nil
	}

	if err := validate.MaxLength("bankName", "body", string(m.BankName), 255); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	for i := 0; i < len(m.Changes); i++ {
		if swag.IsZero(m.Changes[i]) { // not required
			continue
		}

		if m.Changes[i] != nil {
			if err := m.Changes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("changes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Account) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency")
			}
			return err
		}
	}

	return nil
}

func (m *Account) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 255); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("number", "body", m.Number); err != nil {
		return err
	}

	if err := validate.MinimumInt("number", "body", int64(*m.Number), 0, false); err != nil {
		return err
	}

	return nil
}

var accountTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ASSETS","EQUITY","LIABILITIES","OPERATING_REVENUES","OPERATING_EXPENSES","INVESTMENT_INCOME","COST_OF_CAPITAL","TAX_ON_ORDINARY_ACTIVITIES","EXTRAORDINARY_INCOME","EXTRAORDINARY_COST","TAX_ON_EXTRAORDINARY_ACTIVITIES","ANNUAL_RESULT","TRANSFERS_AND_ALLOCATIONS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		accountTypeTypePropEnum = append(accountTypeTypePropEnum, v)
	}
}

const (

	// AccountTypeASSETS captures enum value "ASSETS"
	AccountTypeASSETS string = "ASSETS"

	// AccountTypeEQUITY captures enum value "EQUITY"
	AccountTypeEQUITY string = "EQUITY"

	// AccountTypeLIABILITIES captures enum value "LIABILITIES"
	AccountTypeLIABILITIES string = "LIABILITIES"

	// AccountTypeOPERATINGREVENUES captures enum value "OPERATING_REVENUES"
	AccountTypeOPERATINGREVENUES string = "OPERATING_REVENUES"

	// AccountTypeOPERATINGEXPENSES captures enum value "OPERATING_EXPENSES"
	AccountTypeOPERATINGEXPENSES string = "OPERATING_EXPENSES"

	// AccountTypeINVESTMENTINCOME captures enum value "INVESTMENT_INCOME"
	AccountTypeINVESTMENTINCOME string = "INVESTMENT_INCOME"

	// AccountTypeCOSTOFCAPITAL captures enum value "COST_OF_CAPITAL"
	AccountTypeCOSTOFCAPITAL string = "COST_OF_CAPITAL"

	// AccountTypeTAXONORDINARYACTIVITIES captures enum value "TAX_ON_ORDINARY_ACTIVITIES"
	AccountTypeTAXONORDINARYACTIVITIES string = "TAX_ON_ORDINARY_ACTIVITIES"

	// AccountTypeEXTRAORDINARYINCOME captures enum value "EXTRAORDINARY_INCOME"
	AccountTypeEXTRAORDINARYINCOME string = "EXTRAORDINARY_INCOME"

	// AccountTypeEXTRAORDINARYCOST captures enum value "EXTRAORDINARY_COST"
	AccountTypeEXTRAORDINARYCOST string = "EXTRAORDINARY_COST"

	// AccountTypeTAXONEXTRAORDINARYACTIVITIES captures enum value "TAX_ON_EXTRAORDINARY_ACTIVITIES"
	AccountTypeTAXONEXTRAORDINARYACTIVITIES string = "TAX_ON_EXTRAORDINARY_ACTIVITIES"

	// AccountTypeANNUALRESULT captures enum value "ANNUAL_RESULT"
	AccountTypeANNUALRESULT string = "ANNUAL_RESULT"

	// AccountTypeTRANSFERSANDALLOCATIONS captures enum value "TRANSFERS_AND_ALLOCATIONS"
	AccountTypeTRANSFERSANDALLOCATIONS string = "TRANSFERS_AND_ALLOCATIONS"
)

// prop value enum
func (m *Account) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, accountTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Account) validateType(formats strfmt.Registry) error {

	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Account) validateVatType(formats strfmt.Registry) error {

	if swag.IsZero(m.VatType) { // not required
		return nil
	}

	if m.VatType != nil {
		if err := m.VatType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vatType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Account) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Account) UnmarshalBinary(b []byte) error {
	var res Account
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
