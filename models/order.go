// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Order order
//
// swagger:model Order
type Order struct {

	// attn
	Attn *Contact `json:"attn,omitempty"`

	// changes
	// Read Only: true
	Changes []*Change `json:"changes"`

	// contact
	Contact *Contact `json:"contact,omitempty"`

	// currency
	Currency *Currency `json:"currency,omitempty"`

	// customer
	// Required: true
	Customer *Customer `json:"customer"`

	// Delivery address of this order. This can be a new or existing address
	// (useful to know, especially if the delivery is to a private person: if 'deliveryAddress.name' is set, we ignore the state of 'customer.id')
	DeliveryAddress *DeliveryAddress `json:"deliveryAddress,omitempty"`

	// delivery comment
	DeliveryComment string `json:"deliveryComment,omitempty"`

	// delivery date
	// Required: true
	DeliveryDate *string `json:"deliveryDate"`

	// department
	Department *Department `json:"department,omitempty"`

	// id
	ID int32 `json:"id,omitempty"`

	// Comment to be displayed in the invoice based on this order. Can be also found in Invoice.invoiceComment on Invoice objects.
	InvoiceComment string `json:"invoiceComment,omitempty"`

	// Number of days/months in which invoices created from this order is due
	// Maximum: 10000
	// Minimum: 0
	InvoicesDueIn *int32 `json:"invoicesDueIn,omitempty"`

	// Set the time unit of invoicesDueIn. The special case RECURRING_DAY_OF_MONTH enables the due date to be fixed to a specific day of the month, in this case the fixed due date will automatically be set as standard on all invoices created from this order. Note that when RECURRING_DAY_OF_MONTH is set, the due date will be set to the last day of month if "31" is set in invoicesDueIn.
	// Enum: [DAYS MONTHS RECURRING_DAY_OF_MONTH]
	InvoicesDueInType string `json:"invoicesDueInType,omitempty"`

	// Denotes if this order is closed. A closed order can no longer be invoiced unless it is opened again.
	IsClosed *bool `json:"isClosed,omitempty"`

	// is prioritize amounts including vat
	IsPrioritizeAmountsIncludingVat *bool `json:"isPrioritizeAmountsIncludingVat,omitempty"`

	// Show account statement - open posts on invoices created from this order
	IsShowOpenPostsOnInvoices *bool `json:"isShowOpenPostsOnInvoices,omitempty"`

	// If true, the order is a subscription, which enables periodical invoicing of order lines. First, create an order with isSubscription=true, then approve it for subscription invoicing with the :approveSubscriptionInvoice method.
	IsSubscription *bool `json:"isSubscription,omitempty"`

	// Automatic invoicing. Starts when the subscription is approved
	IsSubscriptionAutoInvoicing *bool `json:"isSubscriptionAutoInvoicing,omitempty"`

	// number
	// Max Length: 100
	Number string `json:"number,omitempty"`

	// order date
	// Required: true
	OrderDate *string `json:"orderDate"`

	// order line sorting
	// Enum: [ID PRODUCT CUSTOM]
	OrderLineSorting string `json:"orderLineSorting,omitempty"`

	// Order lines tied to the order
	// Read Only: true
	OrderLines []*OrderLine `json:"orderLines"`

	// If the contact is not an employee
	OurContact *Contact `json:"ourContact,omitempty"`

	// If the contact is an employee
	OurContactEmployee *Employee `json:"ourContactEmployee,omitempty"`

	// overdue notice email
	// Max Length: 254
	// Format: email
	OverdueNoticeEmail strfmt.Email `json:"overdueNoticeEmail,omitempty"`

	// project
	Project *Project `json:"project,omitempty"`

	// receiver email
	// Max Length: 254
	// Format: email
	ReceiverEmail strfmt.Email `json:"receiverEmail,omitempty"`

	// reference
	// Max Length: 255
	Reference string `json:"reference,omitempty"`

	// Number of months/years the subscription shall run
	// Minimum: 0
	SubscriptionDuration *int32 `json:"subscriptionDuration,omitempty"`

	// The time unit of subscriptionDuration
	// Enum: [MONTHS YEAR]
	SubscriptionDurationType string `json:"subscriptionDurationType,omitempty"`

	// Number of days/months invoicing in advance/in arrears
	// Minimum: 0
	SubscriptionInvoicingTime *int32 `json:"subscriptionInvoicingTime,omitempty"`

	// Invoicing in advance/in arrears
	// Enum: [ADVANCE ARREARS]
	SubscriptionInvoicingTimeInAdvanceOrArrears string `json:"subscriptionInvoicingTimeInAdvanceOrArrears,omitempty"`

	// The time unit of subscriptionInvoicingTime
	// Enum: [DAYS MONTHS]
	SubscriptionInvoicingTimeType string `json:"subscriptionInvoicingTimeType,omitempty"`

	// Number of periods on each invoice
	// Minimum: 0
	SubscriptionPeriodsOnInvoice *int32 `json:"subscriptionPeriodsOnInvoice,omitempty"`

	// The time unit of subscriptionPeriodsOnInvoice
	// Read Only: true
	// Enum: [MONTHS]
	SubscriptionPeriodsOnInvoiceType string `json:"subscriptionPeriodsOnInvoiceType,omitempty"`

	// url
	// Read Only: true
	URL string `json:"url,omitempty"`

	// version
	Version int32 `json:"version,omitempty"`
}

// Validate validates this order
func (m *Order) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAttn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDepartment(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoicesDueIn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInvoicesDueInType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderLineSorting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrderLines(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOurContact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOurContactEmployee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOverdueNoticeEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProject(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiverEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReference(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionDurationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionInvoicingTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionInvoicingTimeInAdvanceOrArrears(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionInvoicingTimeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionPeriodsOnInvoice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionPeriodsOnInvoiceType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Order) validateAttn(formats strfmt.Registry) error {

	if swag.IsZero(m.Attn) { // not required
		return nil
	}

	if m.Attn != nil {
		if err := m.Attn.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attn")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	for i := 0; i < len(m.Changes); i++ {
		if swag.IsZero(m.Changes[i]) { // not required
			continue
		}

		if m.Changes[i] != nil {
			if err := m.Changes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("changes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Order) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(m.Contact) { // not required
		return nil
	}

	if m.Contact != nil {
		if err := m.Contact.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contact")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(m.Currency) { // not required
		return nil
	}

	if m.Currency != nil {
		if err := m.Currency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("currency")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateCustomer(formats strfmt.Registry) error {

	if err := validate.Required("customer", "body", m.Customer); err != nil {
		return err
	}

	if m.Customer != nil {
		if err := m.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customer")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateDeliveryAddress(formats strfmt.Registry) error {

	if swag.IsZero(m.DeliveryAddress) { // not required
		return nil
	}

	if m.DeliveryAddress != nil {
		if err := m.DeliveryAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deliveryAddress")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateDeliveryDate(formats strfmt.Registry) error {

	if err := validate.Required("deliveryDate", "body", m.DeliveryDate); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateDepartment(formats strfmt.Registry) error {

	if swag.IsZero(m.Department) { // not required
		return nil
	}

	if m.Department != nil {
		if err := m.Department.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("department")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateInvoicesDueIn(formats strfmt.Registry) error {

	if swag.IsZero(m.InvoicesDueIn) { // not required
		return nil
	}

	if err := validate.MinimumInt("invoicesDueIn", "body", int64(*m.InvoicesDueIn), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("invoicesDueIn", "body", int64(*m.InvoicesDueIn), 10000, false); err != nil {
		return err
	}

	return nil
}

var orderTypeInvoicesDueInTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAYS","MONTHS","RECURRING_DAY_OF_MONTH"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		orderTypeInvoicesDueInTypePropEnum = append(orderTypeInvoicesDueInTypePropEnum, v)
	}
}

const (

	// OrderInvoicesDueInTypeDAYS captures enum value "DAYS"
	OrderInvoicesDueInTypeDAYS string = "DAYS"

	// OrderInvoicesDueInTypeMONTHS captures enum value "MONTHS"
	OrderInvoicesDueInTypeMONTHS string = "MONTHS"

	// OrderInvoicesDueInTypeRECURRINGDAYOFMONTH captures enum value "RECURRING_DAY_OF_MONTH"
	OrderInvoicesDueInTypeRECURRINGDAYOFMONTH string = "RECURRING_DAY_OF_MONTH"
)

// prop value enum
func (m *Order) validateInvoicesDueInTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, orderTypeInvoicesDueInTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Order) validateInvoicesDueInType(formats strfmt.Registry) error {

	if swag.IsZero(m.InvoicesDueInType) { // not required
		return nil
	}

	// value enum
	if err := m.validateInvoicesDueInTypeEnum("invoicesDueInType", "body", m.InvoicesDueInType); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(m.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("number", "body", string(m.Number), 100); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateOrderDate(formats strfmt.Registry) error {

	if err := validate.Required("orderDate", "body", m.OrderDate); err != nil {
		return err
	}

	return nil
}

var orderTypeOrderLineSortingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ID","PRODUCT","CUSTOM"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		orderTypeOrderLineSortingPropEnum = append(orderTypeOrderLineSortingPropEnum, v)
	}
}

const (

	// OrderOrderLineSortingID captures enum value "ID"
	OrderOrderLineSortingID string = "ID"

	// OrderOrderLineSortingPRODUCT captures enum value "PRODUCT"
	OrderOrderLineSortingPRODUCT string = "PRODUCT"

	// OrderOrderLineSortingCUSTOM captures enum value "CUSTOM"
	OrderOrderLineSortingCUSTOM string = "CUSTOM"
)

// prop value enum
func (m *Order) validateOrderLineSortingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, orderTypeOrderLineSortingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Order) validateOrderLineSorting(formats strfmt.Registry) error {

	if swag.IsZero(m.OrderLineSorting) { // not required
		return nil
	}

	// value enum
	if err := m.validateOrderLineSortingEnum("orderLineSorting", "body", m.OrderLineSorting); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateOrderLines(formats strfmt.Registry) error {

	if swag.IsZero(m.OrderLines) { // not required
		return nil
	}

	for i := 0; i < len(m.OrderLines); i++ {
		if swag.IsZero(m.OrderLines[i]) { // not required
			continue
		}

		if m.OrderLines[i] != nil {
			if err := m.OrderLines[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orderLines" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Order) validateOurContact(formats strfmt.Registry) error {

	if swag.IsZero(m.OurContact) { // not required
		return nil
	}

	if m.OurContact != nil {
		if err := m.OurContact.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ourContact")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateOurContactEmployee(formats strfmt.Registry) error {

	if swag.IsZero(m.OurContactEmployee) { // not required
		return nil
	}

	if m.OurContactEmployee != nil {
		if err := m.OurContactEmployee.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ourContactEmployee")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateOverdueNoticeEmail(formats strfmt.Registry) error {

	if swag.IsZero(m.OverdueNoticeEmail) { // not required
		return nil
	}

	if err := validate.MaxLength("overdueNoticeEmail", "body", string(m.OverdueNoticeEmail), 254); err != nil {
		return err
	}

	if err := validate.FormatOf("overdueNoticeEmail", "body", "email", m.OverdueNoticeEmail.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateProject(formats strfmt.Registry) error {

	if swag.IsZero(m.Project) { // not required
		return nil
	}

	if m.Project != nil {
		if err := m.Project.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("project")
			}
			return err
		}
	}

	return nil
}

func (m *Order) validateReceiverEmail(formats strfmt.Registry) error {

	if swag.IsZero(m.ReceiverEmail) { // not required
		return nil
	}

	if err := validate.MaxLength("receiverEmail", "body", string(m.ReceiverEmail), 254); err != nil {
		return err
	}

	if err := validate.FormatOf("receiverEmail", "body", "email", m.ReceiverEmail.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateReference(formats strfmt.Registry) error {

	if swag.IsZero(m.Reference) { // not required
		return nil
	}

	if err := validate.MaxLength("reference", "body", string(m.Reference), 255); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateSubscriptionDuration(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionDuration) { // not required
		return nil
	}

	if err := validate.MinimumInt("subscriptionDuration", "body", int64(*m.SubscriptionDuration), 0, false); err != nil {
		return err
	}

	return nil
}

var orderTypeSubscriptionDurationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MONTHS","YEAR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		orderTypeSubscriptionDurationTypePropEnum = append(orderTypeSubscriptionDurationTypePropEnum, v)
	}
}

const (

	// OrderSubscriptionDurationTypeMONTHS captures enum value "MONTHS"
	OrderSubscriptionDurationTypeMONTHS string = "MONTHS"

	// OrderSubscriptionDurationTypeYEAR captures enum value "YEAR"
	OrderSubscriptionDurationTypeYEAR string = "YEAR"
)

// prop value enum
func (m *Order) validateSubscriptionDurationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, orderTypeSubscriptionDurationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Order) validateSubscriptionDurationType(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionDurationType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubscriptionDurationTypeEnum("subscriptionDurationType", "body", m.SubscriptionDurationType); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateSubscriptionInvoicingTime(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionInvoicingTime) { // not required
		return nil
	}

	if err := validate.MinimumInt("subscriptionInvoicingTime", "body", int64(*m.SubscriptionInvoicingTime), 0, false); err != nil {
		return err
	}

	return nil
}

var orderTypeSubscriptionInvoicingTimeInAdvanceOrArrearsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ADVANCE","ARREARS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		orderTypeSubscriptionInvoicingTimeInAdvanceOrArrearsPropEnum = append(orderTypeSubscriptionInvoicingTimeInAdvanceOrArrearsPropEnum, v)
	}
}

const (

	// OrderSubscriptionInvoicingTimeInAdvanceOrArrearsADVANCE captures enum value "ADVANCE"
	OrderSubscriptionInvoicingTimeInAdvanceOrArrearsADVANCE string = "ADVANCE"

	// OrderSubscriptionInvoicingTimeInAdvanceOrArrearsARREARS captures enum value "ARREARS"
	OrderSubscriptionInvoicingTimeInAdvanceOrArrearsARREARS string = "ARREARS"
)

// prop value enum
func (m *Order) validateSubscriptionInvoicingTimeInAdvanceOrArrearsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, orderTypeSubscriptionInvoicingTimeInAdvanceOrArrearsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Order) validateSubscriptionInvoicingTimeInAdvanceOrArrears(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionInvoicingTimeInAdvanceOrArrears) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubscriptionInvoicingTimeInAdvanceOrArrearsEnum("subscriptionInvoicingTimeInAdvanceOrArrears", "body", m.SubscriptionInvoicingTimeInAdvanceOrArrears); err != nil {
		return err
	}

	return nil
}

var orderTypeSubscriptionInvoicingTimeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DAYS","MONTHS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		orderTypeSubscriptionInvoicingTimeTypePropEnum = append(orderTypeSubscriptionInvoicingTimeTypePropEnum, v)
	}
}

const (

	// OrderSubscriptionInvoicingTimeTypeDAYS captures enum value "DAYS"
	OrderSubscriptionInvoicingTimeTypeDAYS string = "DAYS"

	// OrderSubscriptionInvoicingTimeTypeMONTHS captures enum value "MONTHS"
	OrderSubscriptionInvoicingTimeTypeMONTHS string = "MONTHS"
)

// prop value enum
func (m *Order) validateSubscriptionInvoicingTimeTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, orderTypeSubscriptionInvoicingTimeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Order) validateSubscriptionInvoicingTimeType(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionInvoicingTimeType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubscriptionInvoicingTimeTypeEnum("subscriptionInvoicingTimeType", "body", m.SubscriptionInvoicingTimeType); err != nil {
		return err
	}

	return nil
}

func (m *Order) validateSubscriptionPeriodsOnInvoice(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionPeriodsOnInvoice) { // not required
		return nil
	}

	if err := validate.MinimumInt("subscriptionPeriodsOnInvoice", "body", int64(*m.SubscriptionPeriodsOnInvoice), 0, false); err != nil {
		return err
	}

	return nil
}

var orderTypeSubscriptionPeriodsOnInvoiceTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MONTHS"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		orderTypeSubscriptionPeriodsOnInvoiceTypePropEnum = append(orderTypeSubscriptionPeriodsOnInvoiceTypePropEnum, v)
	}
}

const (

	// OrderSubscriptionPeriodsOnInvoiceTypeMONTHS captures enum value "MONTHS"
	OrderSubscriptionPeriodsOnInvoiceTypeMONTHS string = "MONTHS"
)

// prop value enum
func (m *Order) validateSubscriptionPeriodsOnInvoiceTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, orderTypeSubscriptionPeriodsOnInvoiceTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Order) validateSubscriptionPeriodsOnInvoiceType(formats strfmt.Registry) error {

	if swag.IsZero(m.SubscriptionPeriodsOnInvoiceType) { // not required
		return nil
	}

	// value enum
	if err := m.validateSubscriptionPeriodsOnInvoiceTypeEnum("subscriptionPeriodsOnInvoiceType", "body", m.SubscriptionPeriodsOnInvoiceType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Order) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Order) UnmarshalBinary(b []byte) error {
	var res Order
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
